# 기능 구현 목록

0. 공통 사항

- 숫자나 문자열은 하드코딩 하지 않는다. 상수화하여 관리한다.
- 하나의 파일에서 관리해야할 상수가 너무 많아진다면, 따로 파일을 분리해서 관리한다.
- 상수를 개별적으로 exports 하지말고, 객체의 key-value 형태로 관리하는 것이 깔끔하다고 생각됨.
- UI 로직과 핵심 로직을 분리. Console 관련 코드와 그 외 코드로 구분하여 리팩토링 진행.

1. 구입 금액 입력

- 복권 한 장은 1000원이다.
- 1000단위로 나누어 떨어지지 않을 경우 예외 처리
- 소수점 단위를 입력해도 연산에 문제가 없는 경우가 존재. 예를들어, 8000.0은 8000으로 계산이된다.
- .0은 문제가 없으나 이를 허용하면 추가적인 문제가 발생할 수 있으므로, 소수점은 입력할 수 없게 제한 및 에러 처리
- (추가) 소수점만이 아니라 쉼표, 공백 등 숫자가 아닌 모든 문자에 대해서 예외처리를 하는 것이 더 포괄적이고 안전하므로 정규식으로 숫자문자만 입력받도록 처리
- (추가) 맨 앞이 0으로 시작하는 숫자를 입력하는 경우에 대한 예외 처리. 예를들어, 08000을 입력하면 8000으로 인식된다.

2. 1번에서 입력된 금액에 따라 복권 구입

- 8000원이 입력되었으면, 8개의 복권이 구매된다.
- n개를 구매하면 "n개를 구매했습니다." 출력
- 랜덤 생성된 복권이 중복되는 경우에 대해서는 어떠한 제한 사항도 없기 때문에 용인하는 것으로 판단.

3. 각각의 복권 출력

- [1,2,3,4,5,6] 의 형태로 복권 출력
- 하나의 복권에는 모두 다른 숫자가 들어있어야한다.(API 내부에서 자체 처리됨)
- 1 - 45 사이의 자연수여야한다.(API 내부에서 자체 처리됨)
- 각 복권의 숫자들은 오름차순으로 정렬해서 보여준다.

4. 사용자의 당첨 번호 입력

- , 표시로 입력을 구분해서 입력해야한다.
- 1 - 45 사이의 자연수만 입력 가능하다.
- 모두 다른 숫자를 입력해야한다.
- 입력값 활용에 문제가 없도록 "1,2" 처럼 숫자와 , 표시만 입력하도록 한다.(공백 등 허용 x)
- 위 조건을 만족하지 않을 시 상황에 맞게 에러 메세지를 출력한다.
- 1 - 45 사이의 숫자가 아닐 경우 에러 메세지 "[ERROR] 로또 번호는 1부터 45 사이의 숫자여야 합니다."를 출력한다.
- (추가) 맨 앞이 0으로 시작하는 숫자를 입력하는 경우에 대한 예외 처리. 예를들어, 07을 입력하면 7로 인식된다.

5. 사용자의 보너스 번호 입력

- 하나의 숫자만 입력 받는다.(아래 2개의 조건으로 인해서 자동적으로 충족되므로 구현 x)
- 1 - 45 사이의 자연수를 입력받는다.
- 공백 등 기호는 허용하지않는다. 숫자만이 입력 가능하다.
- 4번에 입력한 번호와 중복값이 없도록 한다.
- 위 조건을 만족하지 않을 시 상황에 맞게 에러 메세지를 출력한다.
- (추가) 맨 앞이 0으로 시작하는 숫자를 입력하는 경우에 대한 예외 처리. 예를들어, 010을 입력하면 10으로 인식된다.

6. 당첨 통계 출력

- 5등, 4등, 3등, 2등, 1등 순서로 출력한다.
- 각 등수에 해당하는 복권의 개수를 출력한다.

7. 수익률 출력

- 수익률은 (총 당첨 금액 / 복권 구매 금액 \* 100)의 계산을 따른다
- 소수점 둘째 자리에서 반올림한다.
- 수익률이 세자리를 넘어가면 ,(쉼표) 표시로 구분해준다. 예를들어, 1,850.5%

// 떠오른 방법 1.
// #numbers를 꼭 3가지 판별이 끝난 다음 넣어야하는건 아님
// 길이 판별만하고, 넣은 다음 나머지 2개 판별을 진행하고, 다른 변수에 최종 확정본을 넣으면 됨
// 그러면 App에서도 사용 가능하고, Lotto에서 BonusNumber 입력하려고 readLine을 안써도 됨. App에서 다 처리할 수 있기 때문
// readLine(App, 금액 입력) -> readLine(App, 당첨 번호 입력) -> readLine(App, 보너스 번호 입력)
// 2번째 readLine에서 Lotto 인스턴스로 간 다음 #numbers를 public화까지 끝냄.
// Lotto 인스턴스 바로 아래에서 3번째 readLine 실행 함수 호출. 보너스 입력하고 BonusNumber 인스턴스 생성 후 판별 진행 및 확정.
// BonusNumber 바로 아래에서 Result 인스턴스 생성. 필요한 인자는 모두 App에 모였으므로 활용 가능.
// 이 방법은 안 좋은게, 비효율적으로 보이기 때문. #numbers에 값을 넣고, 그걸 판별해서, 또 다른 값에 넣는다? 코드 자체가 비효율적으로 보일 수 있음.
// 그래도 이게 #numbers 활용도는 낮아지지만, readLine을 모두 App에서 처리할 수 있게 된다는 점에서는 구조가 좋음.

// 떠오른 방법 2.
// 꼭 보너스 번호에 대한 입력을 Lotto에 구현할 필요는 없음.
// 그냥 BonusNumber에 readLine을 구현하고, Lotto에서는 #numbers만 BonusNumber 인스턴스에 넘겨주면 됨. 인스턴스는 #numbers가 확정된 후에 생성자에서 실행해주면 되고.
// 이렇게 되면 좋은게, App에서는 Lotto를 참조하기 때문에, Lotto의 private값들을 다 사용할 수 있고, 심지어 BonusNumber에 들어있는 readLine을 App에서 꺼내 쓸 수 있음
// 즉, Lotto의 생성자에 BonusNumber의 인스턴스가 들어있어서, App에서 Lotto를 불러내는 것으로 Lotto와 BonusNumber 내부에 접근이 가능하다는 뜻
// #numbers는 private이므로 BonusNumber의 인스턴스에서 꺼내쓰면 됨. BonusNumber에서는 당첨 번호가 private가 아니기 때문.
// readLine(App, 금액 입력) -> readLine(App, 당첨 번호 입력) -> readLine(App, 보너스 번호 입력) : 이게 구현이 가능하게 된다는 뜻
// readLine을 모듈처럼 사용할 생각을 못했던 것 같네
// readLine을 빠져나올 수가 없는 문제 존재.

// 떠오른 방법 3.
// 중요한 점은 readLine을 사용하게 되면 다음으로 넘어가기 위해서는, 해당 readLine의 콜백 내부에서 함수를 실행해야함
// readLine(App, 금액 입력) -> readLine(App, 당첨 번호 입력) -> readLine(Lotto, 보너스 번호 입력)
// 3번째 readLine에서는 BonusNumber 인스턴스 생성을 통해 보너스 번호 판별 및 확정, 당첨 번호 public화
// Lotto에서 판별 완료된 #numbers를 가지고 활용해야함.
// 이 또한..3번째 readLine이 Lotto에 들어있기 때문에 Result를 진행하기 위해서는 인자 전달을 연달아서 해야함. 이러면 주어진 테스트 케이스 불만족.

// 떠오른 방법 4.
// Result에 amount를 안 줘도 되는 이유. 어차피 bundleofLotto의 길이 \* 1000이 구입 금액임...인자로 전달전달전달을 할 필요가 없음.
// 그럼 필요한 인자는 bundleOfLotto, userLotto, bonusNumber. 이렇게 3개

// 떠오른 방법 5.
// App에서 readLine을 다 처리하는 방법은 유지
// 단, Lotto와 BonusNumber를 합친다. 특히나 BonusNumber 관련 메소드는 static 처리해서 readLine에서 바로 인자를 넘겨주는 형식으로 하자.
// 예를들어, Lotto.bonusMethod(bonus) 이런 식으로.
// 이러면 #numbers를 충분히 활용하면서도, 파일 개수를 줄일 수 있고(이건 뭐 의미가 거의 없지만), readLine을 빠져나갈 수도 있고, Result도 필요한 인자를 줄일 수 있음(amount 줄였던것 ㅇㅇ)
// 아...이렇게 하면 private에 접근을 못하는 것 같다..처음 알았네 ㅠㅠ

// 떠오른 방법 6.
// Lotto를 검증으로만 사용한다면?
// 이미 userLotto라는 상수에 처리가 완료된 당첨 숫자들이 들어있기 때문에, Lotto에서는 검증을 통한 에러 출력만 넣어놓는거지.
// 에러가 안나면 코드가 계속 진행되기 때문에, userLotto가 검증된 값이라는 걸 자연스럽게 알 수 있지.
// 이러면 private로 인해 참조가 안되는 문제도 해결 할 수 있음. 사용을 안하는 거지만..
// 또한, 굳이 보너스 번호를 입력하기 위해서 readLine을 Lotto 내에서 사용할 필요가 없게됨.
// 즉, 모든 readLine을 App에서 구현할 수 있고, Lotto, BonusNumber, Result를 유지 할 수 있으며 순환 참조는 걱정하지 않아도 됨.
// 이 방법이 #numbers를 충분히 사용하지는 않는다는 점 외에는, 재할당의 문제같은..뭔가 비효율적인 코드를 없앨 수 있다는 점에서는 좋음.
// 그나마 제한 사항에는 #numbers를 꼭 유용하게 사용하라는 말이 없기 때문에, 이 방법이 참조 구조나, readLine 탈출 문제, 인자 전달 문제 등에서 가장 좋은듯.
// Lotto 생성자에는 하나의 인자를 넣도록 제한이 걸려있기 때문에,

// 떠오른 방법 7.
// 그냥 Lotto에 보너스번호 판별을 넣어. static말고 그냥.
// 그 다음 this.lotto에 Lotto 인스턴스를 저장하고
// App에서 보너스 번호 입력할 때, this.lotto에 있는 함수 꺼내서 bonus 판별을 해.
